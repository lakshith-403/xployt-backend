package com.xployt.controller.hacker;

import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import javax.servlet.annotation.MultipartConfig;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.google.gson.Gson;
import com.xployt.model.Attachment;
import com.xployt.model.GenericResponse;
import com.xployt.model.VulnerabilityReport;
import com.xployt.service.common.VulnerabilityReportService;
import com.xployt.util.CustomLogger;
import com.xployt.util.FileUploadUtil;
import com.xployt.util.JsonUtil;

@WebServlet("/api/reports/vulnerability/edit/*")
@MultipartConfig
public class HackerVulnerabilityReportServlet extends HttpServlet {
    private VulnerabilityReportService vulnerabilityReportService;
    private static final Logger logger = CustomLogger.getLogger();

    @Override
    public void init() {
        vulnerabilityReportService = new VulnerabilityReportService();
    }

    // Handles POST requests to update a vulnerability report
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
        try {
            // Process multipart request
            FileUploadUtil.UploadResult uploadResult = FileUploadUtil.processMultipartRequest(request, response);
            if (uploadResult == null) {
                return;
            }

            String reportJson = uploadResult.getFormField("report");
            if (reportJson == null) {
                response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Report is required");
                return;
            }

            Gson gson = JsonUtil.useGson();
            VulnerabilityReport report = gson.fromJson(reportJson, VulnerabilityReport.class);

            if (!"Pending".equals(report.getStatus()) && !"More Info".equals(report.getStatus())) {
                response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Cannot update report");
                return;
            }

            // Extract attachment IDs from all steps
            List<String> attachmentIds = report.getSteps().stream()
                    .flatMap(step -> step.getAttachments().stream().map(Attachment::getId))
                    .collect(Collectors.toList());

            List<File> uploadedFiles = FileUploadUtil.processAttachments(
                    uploadResult.getFileItems(),
                    attachmentIds,
                    getServletContext(),
                    response
            );

            GenericResponse result = vulnerabilityReportService.updateVulnerabilityReport(report);

            response.setContentType("application/json");
            response.setCharacterEncoding("UTF-8");
            response.getWriter().write(gson.toJson(result));

        } catch (Exception e) {
            logger.log(Level.SEVERE, "Error updating VulnerabilityReport", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Error updating VulnerabilityReport");
        }
    }
}
